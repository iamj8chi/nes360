<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>A-Frame Forest Demo</title>
    <script src="dist/aframe.min.js"></script>
    <script src="dist/aframe-extras.min.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      .hint {
        position: absolute;
        left: 8px;
        top: 8px;
        color: white;
        font-family: sans-serif;
        background: rgba(0, 0, 0, 0.4);
        padding: 6px 8px;
        border-radius: 4px;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <div class="hint">
      WASD / arrow keys to move, mouse to look. In VR, use thumbsticks to move
      and controllers to point. Explore the forest!
    </div>

    <a-scene background="color: #87ceeb">
      <a-assets>
        <!-- Model assets -->
        <a-asset-item
          id="flamingoModel"
          src="assets/flamengo.glb"
        ></a-asset-item>
        <a-asset-item id="samuuModel" src="assets/samuu.glb"></a-asset-item>
      </a-assets>

      <!-- Sky -->
      <a-sky color="#87ceeb"></a-sky>

      <!-- Ocean using a-ocean component -->
      <a-ocean
        width="500"
        depth="500"
        density="40"
        opacity="0.9"
        position="30 -0.5 -10"
      ></a-ocean>

      <!-- Ground (slightly raised) -->
      <a-entity
        geometry="primitive: circle; radius: 50; segments: 32"
        material="color: #3cb371"
        rotation="-90 0 0"
        position="0 0.01 0"
      ></a-entity>

      <!-- Camera rig with WASD and VR controls -->
      <a-entity
        id="cameraRig"
        position="0 1.6 0"
        movement-controls="enabled: true; speed: 0.1;"
        vr-thumbstick-controls
      >
        <!-- Camera and cursor -->
        <a-entity
          id="head"
          camera
          look-controls="pointerLockEnabled: false"
          position="0 0 0"
          wasd-controls="enabled: false"
        >
          <a-entity
            cursor="fuse: false"
            raycaster="objects: .clickable"
            position="0 0 -1"
            geometry="primitive: ring; radiusInner: 0.02; radiusOuter: 0.03"
            material="color: white; shader: flat"
          >
          </a-entity>
        </a-entity>

        <!-- Left Controller -->
        <a-entity
          id="leftHand"
          hand-controls="hand: left"
          laser-controls="hand: left"
          raycaster="objects: .clickable"
          line="color: #FF0000"
        >
        </a-entity>

        <!-- Right Controller -->
        <a-entity
          id="rightHand"
          hand-controls="hand: right"
          laser-controls="hand: right"
          raycaster="objects: .clickable"
          line="color: #FF0000"
        >
        </a-entity>
      </a-entity>

      <!-- Trees with scales 4-6 and further positions -->
      <a-entity id="trees">
        <a-entity
          gltf-model="#samuuModel"
          position="-15 0 -20"
          scale="4.2 4.2 4.2"
          data-collider="true"
          data-collider-radius="2.0"
        ></a-entity>
        <a-entity
          gltf-model="#samuuModel"
          position="18 0 -25"
          scale="5.5 5.5 5.5"
          data-collider="true"
          data-collider-radius="2.2"
        ></a-entity>
        <a-entity
          gltf-model="#samuuModel"
          position="25 0 15"
          scale="4.8 4.8 4.8"
          data-collider="true"
          data-collider-radius="2.0"
        ></a-entity>
        <a-entity
          gltf-model="#samuuModel"
          position="-28 0 -18"
          scale="6 6 6"
          data-collider="true"
          data-collider-radius="2.4"
        ></a-entity>
        <a-entity
          gltf-model="#samuuModel"
          position="30 0 -22"
          scale="5.2 5.2 5.2"
          data-collider="true"
          data-collider-radius="2.1"
        ></a-entity>
        <a-entity
          gltf-model="#samuuModel"
          position="-32 0 12"
          scale="5.8 5.8 5.8"
          data-collider="true"
          data-collider-radius="2.3"
        ></a-entity>
        <a-entity
          gltf-model="#samuuModel"
          position="28 0 28"
          scale="4.5 4.5 4.5"
          data-collider="true"
          data-collider-radius="2.0"
        ></a-entity>
        <a-entity
          gltf-model="#samuuModel"
          position="-35 0 -25"
          scale="5.7 5.7 5.7"
          data-collider="true"
          data-collider-radius="2.3"
        ></a-entity>
        <a-entity
          gltf-model="#samuuModel"
          position="32 0 -32"
          scale="4.7 4.7 4.7"
          data-collider="true"
          data-collider-radius="2.0"
        ></a-entity>
        <a-entity
          gltf-model="#samuuModel"
          position="-25 0 30"
          scale="5.3 5.3 5.3"
          data-collider="true"
          data-collider-radius="2.2"
        ></a-entity>
          data-collider-radius="1.6"
        ></a-entity>
        <a-entity
          gltf-model="#samuuModel"
          position="-6 0 6"
          scale="2 2 2"
          data-collider="true"
          data-collider-radius="1.6"
        ></a-entity>
        <a-entity
          gltf-model="#samuuModel"
          position="-10 0 0"
          scale="3 3 3"
          data-collider="true"
          data-collider-radius="1.6"
        ></a-entity>
      </a-entity>

      <!-- Animals replaced by flamingo GLTF models (animated with animal-behavior) -->
      <a-entity id="animals">
                <a-entity
          gltf-model="#flamingoModel"
          position="0 10 0"
          scale="2 2 2"
          animal-behavior="radius: 8; pathRotation: 30;"
          animation-mixer
        ></a-entity>
        <a-entity
          gltf-model="#flamingoModel"
          position="0 10 0"
          scale="2 2 2"
          animal-behavior="radius: 10; pathRotation: 20;"
          animation-mixer
        ></a-entity>
        <a-entity
          gltf-model="#flamingoModel"
          position="0 10 0"
          scale="2 2 2"
          animal-behavior="radius: 12; pathRotation: 10;"
          animation-mixer
        ></a-entity>
        <a-entity
          gltf-model="#flamingoModel"
          position="0 10 0"
          scale="2 2 2"
          animal-behavior="radius: 14; pathRotation: 0;"
          animation-mixer
        ></a-entity>
        <a-entity
          gltf-model="#flamingoModel"
          position="0 10 0"
          scale="2 2 2"
          animal-behavior="radius: 16; pathRotation: 10"
          animation-mixer
        ></a-entity>
        <a-entity
          gltf-model="#flamingoModel"
          position="0 10 0"
          scale="2 2 2"
          animal-behavior="radius: 18; pathRotation: 20"
          animation-mixer
        ></a-entity>
        <a-entity
          gltf-model="#flamingoModel"
          position="0 10 0"
          scale="2 2 2"
          animal-behavior="radius: 20; pathRotation: 30"
          animation-mixer
        ></a-entity>
      </a-entity>

      <!-- Invisible plane for collisions (optional) moved slightly up to match ground -->
      <a-entity
        id="floor"
        geometry="primitive: plane; width: 100; height: 100"
        rotation="-90 0 0"
        position="0 0.01 0"
        visible="false"
      ></a-entity>

      <script>
        // VR Movement Controls component
        AFRAME.registerComponent("vr-thumbstick-controls", {
          init: function () {
            this.moveSpeed = 0.1;
            this.moveVec = new THREE.Vector3();
            this.bindMethods();
            this.setupListeners();
          },

          bindMethods: function () {
            this.onAxisMove = this.onAxisMove.bind(this);
          },

          setupListeners: function () {
            var el = this.el;
            el.addEventListener("axismove", this.onAxisMove);
          },

          onAxisMove: function (evt) {
            var dPad = evt.detail.axis;
            // Only move if the thumbstick is being pushed
            if (Math.abs(dPad[0]) > 0.2 || Math.abs(dPad[1]) > 0.2) {
              // Get camera direction
              var rotation = this.el.querySelector("#head").object3D.rotation.y;

              // Calculate movement vector
              this.moveVec.x = dPad[0];
              this.moveVec.z = dPad[1];

              // Apply camera rotation to movement
              this.moveVec.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation);

              // Update position
              var pos = this.el.object3D.position;
              pos.x -= this.moveVec.x * this.moveSpeed;
              pos.z -= this.moveVec.z * this.moveSpeed;
            }
          },
        });

        // Animal movement with organic motion
        AFRAME.registerComponent("animal-behavior", {
          schema: {
            speed: { type: "number", default: -0.2 },
            radius: { type: "number", default: 2 },
            yawOffset: { type: "number", default: 0 },
            modelRotation: { type: "number", default: -90 },
            pathRotation: { type: "number", default: 0 },
            // Position wiggle parameters
            positionWiggleX: { type: "number", default: 0.3 },  // Amplitude of X wiggle
            positionWiggleY: { type: "number", default: 0.2 },  // Amplitude of Y wiggle
            positionWiggleZ: { type: "number", default: 0.25 }, // Amplitude of Z wiggle
            // Rotation wiggle parameters
            rotationWiggleX: { type: "number", default: 5 },    // Max pitch wiggle in degrees
            rotationWiggleY: { type: "number", default: 3 },    // Max yaw wiggle in degrees
            rotationWiggleZ: { type: "number", default: 8 }     // Max roll wiggle in degrees
          },
          init: function () {
            this.startTime = Date.now();
            this.center = this.el.object3D.position.clone();
            this.pathRotationRad = this.data.pathRotation * (Math.PI / 180);
            
            // Random phase offsets for organic feel
            this.phaseOffsets = {
              pos: {
                x: Math.random() * Math.PI * 2,
                y: Math.random() * Math.PI * 2,
                z: Math.random() * Math.PI * 2
              },
              rot: {
                x: Math.random() * Math.PI * 2,
                y: Math.random() * Math.PI * 2,
                z: Math.random() * Math.PI * 2
              }
            };
          },
          
          // Eased sine wave function
          easedSine: function(t, amplitude, frequency, phaseOffset) {
            // Combine two sine waves for more organic motion
            return amplitude * (
              Math.sin(t * frequency + phaseOffset) * 0.7 +
              Math.sin(t * frequency * 1.3 + phaseOffset * 2.1) * 0.3
            );
          },
          
          tick: function (t, dt) {
            const elapsed = (Date.now() - this.startTime) / 1000;
            const r = this.data.radius;
            const speed = this.data.speed;
            
            // Base circular motion
            const ang = elapsed * speed + this.pathRotationRad;
            const baseX = this.center.x + Math.cos(ang) * r;
            const baseZ = this.center.z + Math.sin(ang) * r;
            
            // Position wiggle
            const wiggleX = this.easedSine(elapsed, this.data.positionWiggleX, 1.5, this.phaseOffsets.pos.x);
            const wiggleY = this.easedSine(elapsed, this.data.positionWiggleY, 2.1, this.phaseOffsets.pos.y);
            const wiggleZ = this.easedSine(elapsed, this.data.positionWiggleZ, 1.8, this.phaseOffsets.pos.z);
            
            // Apply position with wiggle
            const nx = baseX + wiggleX;
            const ny = this.center.y + wiggleY;
            const nz = baseZ + wiggleZ;
            
            // Update position
            this.el.setAttribute("position", `${nx} ${ny} ${nz}`);

            // Calculate base movement direction
            const tangentX = Math.sin(ang) * r;
            const tangentZ = Math.cos(ang) * r;
            const baseYaw = (Math.atan2(tangentZ, tangentX) * (180 / Math.PI)) + this.data.yawOffset + this.data.modelRotation;
            
            // Rotation wiggle
            const rotWiggleX = this.easedSine(elapsed, this.data.rotationWiggleX, 2.3, this.phaseOffsets.rot.x);
            const rotWiggleY = this.easedSine(elapsed, this.data.rotationWiggleY, 1.7, this.phaseOffsets.rot.y);
            const rotWiggleZ = this.easedSine(elapsed, this.data.rotationWiggleZ, 2.0, this.phaseOffsets.rot.z);
            
            // Apply rotation with wiggle
            this.el.setAttribute("rotation", 
              `${rotWiggleX} ${baseYaw + rotWiggleY} ${rotWiggleZ}`);
            const curY = this.el.getAttribute("position")?.y ?? this.center.y;
            this.el.setAttribute("position", `${nx} ${curY} ${nz}`);

            // compute tangent direction and add yaw offset
            const tx = Math.sin(ang) * r;
            const tz = Math.cos(ang) * r;
            // angle in radians where 0 points along +X; convert to degrees and set rotation around Y
            const yaw =
              (Math.atan2(tz, tx) * (180 / Math.PI)) + this.data.yawOffset + this.data.modelRotation;
            this.el.setAttribute("rotation", `0 ${yaw} 0`);
          },
        });

        // Prevent cameraRig from falling below ground if physics not used
        AFRAME.registerComponent("stay-grounded", {
          tick: function () {
            const rig = document.querySelector("#cameraRig");
            if (!rig) return;
            const p = rig.getAttribute("position");
            if (p.y < 1.6) rig.setAttribute("position", `${p.x} 1.6 ${p.z}`);
          },
        });
        document.querySelector("#cameraRig").setAttribute("stay-grounded", "");

        // Simple collider-check: prevents cameraRig from passing through entities marked with data-collider
        AFRAME.registerComponent("collider-check", {
          schema: {
            padding: { type: "number", default: 0.4 },
          },
          init: function () {
            this.rig = document.querySelector("#cameraRig");
            this.colliders = Array.from(
              document.querySelectorAll('[data-collider="true"]')
            );
          },
          tick: function () {
            if (!this.rig) return;
            const rigPos = this.rig.getAttribute("position");
            let x = rigPos.x,
              y = rigPos.y,
              z = rigPos.z;

            // check tree colliders (spherical approximation)
            for (const el of this.colliders) {
              const radius =
                parseFloat(el.getAttribute("data-collider-radius")) || 1.2;
              const p = el.getAttribute("position");
              const dx = x - p.x;
              const dz = z - p.z;
              const dist = Math.sqrt(dx * dx + dz * dz);
              const min = radius + this.data.padding;
              if (dist < min && dist > 0.0001) {
                // push rig out along the vector between collider center and rig
                const nx = (dx / dist) * min + p.x;
                const nz = (dz / dist) * min + p.z;
                this.rig.setAttribute("position", `${nx} ${y} ${nz}`);
                x = nx;
                z = nz;
              }
            }
          },
        });
        // enable collider-check on the scene so it runs each tick
        document.querySelector("a-scene").setAttribute("collider-check", "");

        // Add random trees on page load
        window.addEventListener("load", () => {
          const treeContainer = document.querySelector("#trees");
          const numTrees = 15; // number of additional random trees
          const minDist = 5; // minimum distance between trees
          const maxRadius = 40; // maximum distance from center

          // Helper to get random position with minimum distance from existing trees
          function getValidPosition() {
            for (let attempts = 0; attempts < 50; attempts++) {
              const angle = Math.random() * Math.PI * 2;
              const radius = Math.random() * maxRadius;
              const x = Math.cos(angle) * radius;
              const z = Math.sin(angle) * radius;

              // Check distance from existing trees
              let valid = true;
              const existingTrees = treeContainer.children;
              for (let tree of existingTrees) {
                const pos = tree.getAttribute("position");
                const dx = x - pos.x;
                const dz = z - pos.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist < minDist) {
                  valid = false;
                  break;
                }
              }
              if (valid) return { x, z };
            }
            return null; // no valid position found
          }

          // Add random trees
          for (let i = 0; i < numTrees; i++) {
            const pos = getValidPosition();
            if (pos) {
              const scale = 2 + Math.random(); // random scale between 2-3
              const tree = document.createElement("a-entity");
              tree.setAttribute("gltf-model", "#samuuModel");
              tree.setAttribute("position", `${pos.x} 0 ${pos.z}`);
              tree.setAttribute("scale", `${scale} ${scale} ${scale}`);
              tree.setAttribute("data-collider", "true");
              tree.setAttribute("data-collider-radius", "1.6");
              treeContainer.appendChild(tree);
            }
          }
        });
      </script>
    </a-scene>
  </body>
</html>
